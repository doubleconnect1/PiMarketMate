<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pi App Test (Blog Guide Style)</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; }
        .container { background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        button { padding: 10px 15px; margin: 5px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        #userInfo, #paymentStatus, #insultArea { margin-top: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: #e9ecef; }
        pre { background-color: #333; color: #fff; padding: 10px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Pi App Test - Blog Style</h1>
        <p>Welcome, <span id="usernamePlaceholder">Pioneer</span>!</p>

        <div id="userInfo">
            User Info: <span id="authStatus">Authenticating...</span><br>
            Access Token: <span id="accessTokenDisplay">N/A</span>
        </div>

        <hr>
        <h2>Insult-o-Meter (Simplified)</h2>
        <button id="getInsultBtn">Get Insult (Simulated)</button>
        <div id="insultArea">Click the button!</div>
        <p>Insults remaining: <span id="insultCount">3</span></p>
        <button id="payForInsultsBtn" style="display:none;">Pay 0.01 Pi for More Insults</button>

        <div id="paymentStatus">
            Payment Status: Idle
        </div>

        <hr>
        <h2>Debug Log:</h2>
        <pre id="debugLog"></pre>
    </div>

    <!-- 1. Include the Pi SDK -->
    <script src="https://sdk.minepi.com/pi-sdk.js"></script>
    <script>
        const debugLogElement = document.getElementById('debugLog');
        const usernamePlaceholder = document.getElementById('usernamePlaceholder');
        const authStatusElement = document.getElementById('authStatus');
        const accessTokenDisplayElement = document.getElementById('accessTokenDisplay');
        const paymentStatusElement = document.getElementById('paymentStatus');
        const getInsultBtn = document.getElementById('getInsultBtn');
        const payForInsultsBtn = document.getElementById('payForInsultsBtn');
        const insultArea = document.getElementById('insultArea');
        const insultCountElement = document.getElementById('insultCount');

        let insultsRemaining = 3;
        let currentAccessToken = null;
        let currentUsername = null;

        function log(message) {
            console.log(message);
            const now = new Date();
            const timeString = `${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}.${now.getMilliseconds()}`;
            debugLogElement.textContent = `[${timeString}] ${typeof message === 'object' ? JSON.stringify(message) : message}\n` + debugLogElement.textContent;
        }

        log("Page loaded. Pi SDK script included.");

        // 2. Initialize the Pi SDK for Sandbox
        // As per the blog post, for sandbox.minepi.com development, sandbox: true is used.
        // This should be called once.
        try {
            if (window.Pi) {
                log("Pi object found. Initializing SDK for sandbox...");
                window.Pi.init({ version: "2.0", sandbox: true, appId: 'YOUR_APP_ID_FROM_PORTAL' }); // Replace with your actual app ID if you have one, otherwise can be placeholder for sandbox
                log("Pi.init called with sandbox: true.");
            } else {
                log("ERROR: window.Pi not found! SDK did not load.");
                alert("Pi SDK not loaded. This app won't work.");
            }
        } catch (err) {
            log(`ERROR during Pi.init: ${err.message}`);
            alert(`Error initializing Pi SDK: ${err.message}`);
        }


        // 3. Authenticate the User
        async function authenticateUser() {
            log("Attempting Pi.authenticate...");
            const scopes = ['username', 'payments']; // As per blog post for username and payments

            function onIncompletePaymentFound(payment) {
                log('onIncompletePaymentFound triggered by Pi.authenticate or Pi.createPayment');
                log({ message: "Incomplete payment found:", paymentDetails: payment });
                paymentStatusElement.textContent = `Incomplete payment found: ${payment.identifier}. Attempting to complete...`;

                // Simulate backend call to complete
                // $.post('/payment/complete', { paymentId: payment.identifier, txid: payment.transaction.txid });
                // For this HTML-only test, we'll just log it.
                // In a real app with a backend, you'd call your backend here.
                const paymentId = payment.identifier;
                const txid = payment.transaction ? payment.transaction.txid : 'N/A (from auth incomplete)';
                log(`Simulating backend call: /payment/complete for paymentId: ${paymentId}, txid: ${txid}`);
                // Call your backend to complete this payment
                // This is a critical step the blog author implemented on their server.
                // Example: mockServerCall('/payment/complete', { paymentId, txid }, "POST");
                 // If successful, the user might get their content.
            };

            try {
                const auth = await window.Pi.authenticate(scopes, onIncompletePaymentFound);
                log({ message: "Authentication successful!", authResult: auth });
                authStatusElement.textContent = `Authenticated as ${auth.user.username}`;
                usernamePlaceholder.textContent = auth.user.username;
                currentUsername = auth.user.username;
                accessTokenDisplayElement.textContent = auth.accessToken.substring(0, 15) + "...";
                currentAccessToken = auth.accessToken;
            } catch (err) {
                log({ message: "Authentication failed.", error: err });
                authStatusElement.textContent = "Authentication failed: " + (err.message || JSON.stringify(err));
            }
        }

        // Call authentication when the script runs
        if (window.Pi) {
            authenticateUser();
        }


        // 4. Simulate "Get Insult" and Payment Trigger
        const MOCK_INSULTS = ["Your mother was a hamster.", "Your father smelt of elderberries.", "You fight like a dairy farmer.", "You silly English K-nig-ht!"];
        let insultIndex = 0;

        getInsultBtn.addEventListener('click', () => {
            if (insultsRemaining > 0) {
                insultArea.textContent = MOCK_INSULTS[insultIndex % MOCK_INSULTS.length];
                insultIndex++;
                insultsRemaining--;
                insultCountElement.textContent = insultsRemaining;
                log(`Displayed insult. Remaining: ${insultsRemaining}`);
                if (insultsRemaining === 0) {
                    payForInsultsBtn.style.display = 'block';
                    log("Out of insults, showing payment button.");
                }
            } else {
                log("Attempted to get insult, but none remaining. Payment button should be visible.");
                alert("You're out of insults! Please pay for more.");
            }
        });

        payForInsultsBtn.addEventListener('click', () => {
            log("Pay button clicked. Initiating createPayment flow.");
            if (!currentAccessToken) {
                log("ERROR: No access token. Cannot create payment. Please authenticate.");
                alert("Authentication needed to make a payment. Please refresh.");
                return;
            }
            createPiPayment();
        });


        // 5. Create a Payment (Frontend Part)
        function createPiPayment() {
            log("createPiPayment function called.");
            paymentStatusElement.textContent = "Payment initiated...";

            const paymentData = {
                amount: 0.01, // Test amount
                memo: "For 3 more insults from Test App!",
                metadata: { insultPurchase: true, userId: currentUsername, timestamp: Date.now() }
            };

            const callbacks = {
                onReadyForServerApproval: function(paymentId) {
                    log({ message: "onReadyForServerApproval callback triggered.", paymentId: paymentId });
                    paymentStatusElement.textContent = `Payment ${paymentId} ready for server approval.`;

                    // Simulate backend call to /payment/approve
                    // The blog post uses $.post('/payment/approve', { paymentId: paymentId, accessToken: currentAccessToken });
                    log(`Simulating backend call: /payment/approve for paymentId: ${paymentId}`);
                    log(`   (Would send: paymentId=${paymentId}, accessToken=${currentAccessToken ? currentAccessToken.substring(0,10)+'...' : 'N/A'})`);
                    // In a real app:
                    // fetch('/payment/approve', {
                    //     method: 'POST',
                    //     headers: { 'Content-Type': 'application/json' },
                    //     body: JSON.stringify({ paymentId: paymentId, accessToken: currentAccessToken })
                    // })
                    // .then(response => response.json())
                    // .then(data => log({message: "Approval response from (simulated) server:", data}))
                    // .catch(err => log({message:"Error in (simulated) approval call:", err}));
                    // For this test, we assume the sandbox handles the approval UI and the SDK moves to the next step if user approves in Pi popup.
                },
                onReadyForServerCompletion: function(paymentId, txid) {
                    log({ message: "onReadyForServerCompletion callback triggered.", paymentId: paymentId, txid: txid });
                    paymentStatusElement.textContent = `Payment ${paymentId} ready for server completion. TXID: ${txid}`;

                    // Simulate backend call to /payment/complete
                    // The blog post uses $.post('/payment/complete', { paymentId: paymentId, txid: txid });
                    log(`Simulating backend call: /payment/complete for paymentId: ${paymentId}, txid: ${txid}`);
                    // In a real app:
                    // fetch('/payment/complete', {
                    //     method: 'POST',
                    //     headers: { 'Content-Type': 'application/json' },
                    //     body: JSON.stringify({ paymentId: paymentId, txid: txid })
                    // })
                    // .then(response => response.json())
                    // .then(data => {
                    //    log({message: "Completion response from (simulated) server:", data});
                    //    paymentStatusElement.textContent = `Payment ${paymentId} completed! TXID: ${txid}. You got more insults!`;
                    //    insultsRemaining = 3;
                    //    insultCountElement.textContent = insultsRemaining;
                    //    payForInsultsBtn.style.display = 'none';
                    // })
                    // .catch(err => log({message:"Error in (simulated) completion call:", err}));
                    // For this test, we just update UI assuming completion:
                    paymentStatusElement.textContent = `Payment ${paymentId} COMPLETED! TXID: ${txid}. You got more insults!`;
                    insultsRemaining = 3;
                    insultCountElement.textContent = insultsRemaining;
                    payForInsultsBtn.style.display = 'none';
                    insultArea.textContent = "Payment successful! Get your new insults.";
                },
                onCancel: function(paymentId) {
                    log({ message: "onCancel callback triggered.", paymentId: paymentId });
                    paymentStatusElement.textContent = `Payment ${paymentId || 'N/A'} cancelled by user.`;
                    // Simulate backend call to /payment/cancel or /payment/complete with cancel flag
                    // The blog post calls /payment/complete with a debug: 'cancel' flag.
                    // $.post('/payment/complete', { paymentId: paymentId, debug: 'cancel'});
                    log(`Simulating backend call: /payment/cancel for paymentId: ${paymentId}`);
                },
                onError: function(error, payment) { // The blog had paymentDTO, SDK docs often show error, payment
                    log({ message: "onError callback triggered.", errorDetails: error, paymentDetails: payment });
                    const paymentId = payment ? payment.identifier : (error.payment && error.payment.identifier) || 'N/A';
                    paymentStatusElement.textContent = `Payment Error for ${paymentId}: ${error.message || JSON.stringify(error)}`;
                    // Simulate backend call to /payment/error or /payment/cancel
                    // The blog post calls /payment/error, which then calls cancel.
                    // $.post('/payment/error', { paymentDTO: error, paymentId: paymentId, debug: 'error'});
                    log(`Simulating backend call: /payment/error for paymentId: ${paymentId}`);
                }
                // Note: The blog also has onIncompletePaymentFound inside createPayment callbacks.
                // The Pi.authenticate call already has one. It's good practice if a payment
                // could become incomplete during the createPayment flow itself before authenticate's check.
                // For simplicity here, we'll rely on the one in authenticate.
            };

            try {
                if (window.Pi && typeof window.Pi.createPayment === 'function') {
                    log({ message: "Calling Pi.createPayment with data:", paymentData });
                    window.Pi.createPayment(paymentData, callbacks);
                } else {
                    log("ERROR: Pi.createPayment is not available!");
                    alert("Pi.createPayment is not available. SDK issue?");
                }
            } catch (err) {
                log(`ERROR during Pi.createPayment call: ${err.message}`);
                paymentStatusElement.textContent = `Error calling createPayment: ${err.message}`;
            }
        }

        log("App script fully loaded and event listeners attached.");
    </script>
</body>
</html>
