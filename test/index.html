<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pi Market Mate</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
</head>
<body class="bg-gray-100 font-sans">
  <div class="container mx-auto p-4 max-w-lg">
    <h1 class="text-2xl font-bold mb-4 text-center">Pi Market Mate</h1>

    <!-- Currency Selection -->
    <div class="mb-4">
      <label for="currency" class="block text-sm font-medium text-gray-700">1. SELECT CURRENCY:</label>
      <select id="currency" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
        <option value="USD">USD</option>
        <option value="EUR">EUR</option>
        <option value="GBP">GBP</option>
        <option value="JPY">JPY</option>
        <option value="KRW">KRW</option>
      </select>
      <span id="currency-check" class="hidden text-green-500 text-sm mt-1">✓ Valid currency</span>
    </div>

    <!-- Mode Toggle -->
    <div class="mb-4 flex space-x-2">
      <button id="usd-to-pi-btn" class="flex-1 bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition">Currency to Pi</button>
      <button id="pi-to-usd-btn" class="flex-1 bg-gray-300 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-400 transition">Pi to Currency</button>
    </div>

    <!-- Amount Input -->
    <div class="mb-4">
      <label id="input-label-text" class="block text-sm font-medium text-gray-700">2. ENTER AMOUNT (USD):</label>
      <input id="amount" type="number" step="0.01" min="0" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., 100">
      <span id="amount-check" class="hidden text-green-500 text-sm mt-1">✓ Valid amount</span>
    </div>

    <!-- Pi Price -->
    <div class="mb-4">
      <p class="text-sm">Current Pi Price: <span id="pi-price" class="font-medium">Loading...</span></p>
      <label for="manual-price" class="block text-sm font-medium text-gray-700 mt-2">Manual Price (optional):</label>
      <input id="manual-price" type="number" step="0.0001" min="0" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., 0.1234">
    </div>

    <!-- Calculate Button -->
    <button id="calculate-btn" class="w-full bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 transition mb-4">Calculate</button>

    <!-- Result -->
    <div id="result" class="hidden mb-4 p-4 bg-blue-100 rounded-md">
      <span id="result-text-prefix" class="font-medium"></span>
      <span id="result-value" class="font-bold"></span>
    </div>

    <!-- Error Message -->
    <div id="error" class="hidden mb-4 p-4 bg-red-100 text-red-600 rounded-md">
      <span id="error-message"></span>
    </div>

    <!-- Pay with Pi -->
    <button id="pay-with-pi-btn" class="w-full bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition mb-4">Pay with Pi</button>

    <!-- Debug Button -->
    <button id="debug-btn" class="w-full bg-purple-600 text-white px-4 py-2 rounded-md hover:bg-purple-700 transition mb-4">Debug Pi SDK</button>

    <!-- Debug Panel -->
    <div id="debug-panel" class="hidden mb-4 p-4 bg-gray-200 rounded-md">
      <h2 class="text-lg font-semibold text-gray-700">Debug Info</h2>
      <pre id="debug-content" class="whitespace-pre-wrap text-sm text-gray-600"></pre>
      <button id="close-debug" class="mt-2 bg-gray-300 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-400 transition">Close</button>
    </div>

    <!-- Recent Calculations -->
    <div class="mb-6">
      <h2 class="text-lg font-semibold text-gray-700">Recent Calculations</h2>
      <ul id="recent-calculations" class="list-disc pl-5 text-sm text-gray-600"></ul>
    </div>

    <!-- Donation -->
    <div class="mb-4 text-center">
      <a id="donation-link" href="#" class="text-blue-600 hover:underline">Donate to Pi Market Mate</a>
    </div>
    <div id="overlay" class="hidden fixed inset-0 bg-black bg-opacity-50"></div>
    <div id="donation-popup" class="hidden fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-white p-6 rounded-md shadow-lg max-w-sm w-full">
      <h2 class="text-lg font-semibold mb-4">Donate</h2>
      <select id="donation-amount-select" class="mb-4 w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
        <option value="1">1 Pi</option>
        <option value="5">5 Pi</option>
        <option value="10">10 Pi</option>
      </select>
      <div class="flex space-x-2">
        <button id="confirm-donation" class="flex-1 bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 transition">Confirm</button>
        <button id="cancel-donation" class="flex-1 bg-gray-300 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-400 transition">Cancel</button>
      </div>
    </div>

    <!-- Text Viewer -->
    <div id="text-viewer" class="hidden mt-4 p-4 bg-gray-50 rounded-md">
      <pre id="text-content" class="whitespace-pre-wrap text-sm"></pre>
      <div id="text-fallback" class="hidden text-red-600 text-sm"></div>
      <div class="mt-2">
        <a id="text-download-link" href="#" class="text-blue-600 hover:underline">Download</a>
        <button id="close-text" class="ml-4 bg-gray-300 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-400 transition">Close</button>
      </div>
    </div>

    <!-- Footer Links -->
    <div class="mt-6 text-center text-sm">
      <a id="privacy-policy-link" href="#" class="text-blue-600 hover:underline">Privacy Policy</a>
      <span class="mx-2">|</span>
      <a id="terms-of-service-link" href="#" class="text-blue-600 hover:underline">Terms of Service</a>
    </div>
  </div>

  <script>
    // XLSX Processing
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
      return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
      if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
        try {
          var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
          var firstSheetName = workbook.SheetNames[0];
          var worksheet = workbook.Sheets[firstSheetName];
          var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
          var filteredData = jsonData.filter(row => row.some(filledCell));
          var headerRowIndex = filteredData.findIndex((row, index) =>
            row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
          );
          if (headerRowIndex === -1 || headerRowIndex > 25) {
            headerRowIndex = 0;
          }
          var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
          csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
          return csv;
        } catch (e) {
          console.error('XLSX processing error:', e);
          return "";
        }
      }
      return gk_fileData[filename] || "";
    }

    // App Logic
    let currentMode = 'usd-to-pi';
    let lastPiPrices = {
      AFN: null, ALL: null, DZD: null, EUR: null, AOA: null, XCD: null, ARS: null, AMD: null, AUD: null, AZN: null,
      BSD: null, BHD: null, BDT: null, BBD: null, BYN: null, BZD: null, XOF: null, BTN: null, BOB: null, BAM: null,
      BWP: null, BRL: null, BND: null, BGN: null, BIF: null, KHR: null, XAF: null, CAD: null, CVE: null, CLP: null,
      CNY: null, COP: null, KMF: null, CDF: null, CRC: null, HRK: null, CUP: null, CZK: null, DKK: null, DJF: null,
      DOP: null, USD: null, EGP: null, ERN: null, ETB: null, FJD: null, GMD: null, GEL: null, GHS: null, GTQ: null,
      GNF: null, GYD: null, HTG: null, HNL: null, HKD: null, HUF: null, ISK: null, INR: null, IDR: null, IRR: null,
      IQD: null, ILS: null, JMD: null, JPY: null, JOD: null, KZT: null, KES: null, KRW: null, KWD: null, KGS: null,
      LAK: null, LBP: null, LSL: null, LRD: null, LYD: null, CHF: null, MGA: null, MWK: null, MYR: null, MVR: null,
      MRO: null, MUR: null, MXN: null, MDL: null, MNT: null, MAD: null, MZN: null, MMK: null, NAD: null, NPR: null,
      NZD: null, NIO: null, NGN: null, MKD: null, NOK: null, OMR: null, PKR: null, PGK: null, PYG: null, PEN: null,
      PHP: null, PLN: null, QAR: null, RON: null, RUB: null, RWF: null, STD: null, SAR: null, RSD: null, SCR: null,
      SLL: null, SGD: null, SBD: null, SOS: null, ZAR: null, SSP: null, LKR: null, SDG: null, SRD: null, SEK: null,
      SYP: null, TWD: null, TJS: null, TZS: null, THB: null, TOP: null, TTD: null, TND: null, TRY: null, TMT: null,
      VUV: null, UGX: null, UAH: null, AED: null, GBP: null, UYU: null, UZS: null, VEF: null, VND: null, YER: null,
      ZMW: null, ZWL: null
    };
    let currentCurrency = localStorage.getItem('piMarketMateCurrency') || 'USD';
    let lastCalculatedPiAmount = null;
    let recentCalculations = JSON.parse(localStorage.getItem('piMarketMateCalculations')) || [];

    let Pi;
    let sdkLoadAttempts = 0;
    const maxAttempts = 3;
    const sdkUrls = [
      'https://sdk.minepi.com/pi-sdk.js?v=1',
      'https://sdk.minepi.com/pi-sdk-2.0.0.js?v=1',
      'https://sdk.minepi.com/pi-sdk-1.0.0.js?v=1'
    ];

    function loadSdk(url) {
      return new Promise((resolve, reject) => {
        console.log(`Checkpoint: Attempting to load SDK from: ${url}`);
        const script = document.createElement('script');
        script.src = url;
        script.async = true;
        script.onload = () => {
          console.log(`Checkpoint: SDK script loaded successfully from: ${url}`);
          if (window.Pi) {
            Pi = window.Pi;
            console.log('Checkpoint: window.Pi is defined:', Object.keys(window.Pi));
          } else {
            console.warn('Checkpoint: window.Pi is undefined after loading:', url);
          }
          resolve();
        };
        script.onerror = (error) => {
          console.error(`Checkpoint: Failed to load SDK from: ${url}`, {
            message: error.message || 'Unknown error',
            stack: error.stack
          });
          reject(new Error(`Failed to load SDK from ${url}: ${error.message || 'Unknown error'}`));
        };
        document.head.appendChild(script);
      });
    }

    async function ensurePiSDKReady(maxRetries = 10, delayMs = 2000, timeoutMs = 30000) {
      console.log('Checkpoint: Starting ensurePiSDKReady with:', { maxRetries, delayMs, timeoutMs });
      try {
        while (sdkLoadAttempts < maxAttempts && !window.Pi) {
          console.log(`Checkpoint: Loading SDK attempt ${sdkLoadAttempts + 1}/${maxAttempts}`);
          try {
            await loadSdk(sdkUrls[sdkLoadAttempts]);
            break;
          } catch (err) {
            sdkLoadAttempts++;
            console.error(`Checkpoint: SDK load attempt ${sdkLoadAttempts}/${maxAttempts} failed:`, {
              message: err.message || 'Unknown error',
              stack: err.stack
            });
            if (sdkLoadAttempts >= maxAttempts) {
              throw new Error('Failed to load Pi SDK after all attempts');
            }
          }
        }

        if (!window.Pi) {
          throw new Error('Pi SDK not found after loading attempts. Ensure Pi Browser is used.');
        }

        console.log('Checkpoint: Pi SDK object properties:', Object.keys(window.Pi));
        const isReady = (typeof window.Pi.isReady === 'boolean' && window.Pi.isReady) || 
                        (typeof window.Pi.initialized === 'boolean' && window.Pi.initialized);
        if (isReady) {
          console.log('Checkpoint: Pi SDK is ready on initial check (isReady:', window.Pi.isReady, ', initialized:', window.Pi.initialized, ')');
          return true;
        }

        let retries = 0;
        let hasResolved = false;
        const versions = ['1.0', '2.0'];
        let useSandbox = true;

        // Check Testnet health to decide sandbox mode
        try {
          console.log('Checkpoint: Checking Testnet health before initialization...');
          const response = await fetch('https://api.testnet.minepi.com/v2/health', {
            method: 'GET',
            headers: {
              'Authorization': 'Key xxphzwyfmzalumwmiewge3hshjos3dsqwemu1hyuerpiomyff97grrsgxfvhpzdq'
            },
            signal: AbortSignal.timeout(5000)
          });
          if (!response.ok) {
            console.warn('Checkpoint: Testnet health check failed:', response.status, response.statusText);
            useSandbox = false;
          }
        } catch (error) {
          console.warn('Checkpoint: Testnet health check error:', {
            message: error.message || 'Unknown error',
            stack: error.stack
          });
          useSandbox = false;
        }
        console.log('Checkpoint: Using sandbox mode:', useSandbox);

        async function tryInit(version) {
          console.log(`Checkpoint: Attempting Pi.init with version ${version}, sandbox: ${useSandbox}`);
          try {
            await window.Pi.init({ version, appId: 'marketmate', sandbox: useSandbox });
            const postInitReady = (typeof window.Pi.isReady === 'boolean' && window.Pi.isReady) || 
                                  (typeof window.Pi.initialized === 'boolean' && window.Pi.initialized);
            console.log(`Checkpoint: Pi.init completed with version ${version} (sandbox: ${useSandbox})`, {
              isReady: window.Pi.isReady,
              initialized: window.Pi.initialized,
              postInitReady
            });
            return postInitReady;
          } catch (error) {
            console.error(`Checkpoint: Pi.init failed with version ${version} (sandbox: ${useSandbox}):`, {
              message: error.message || 'Unknown error',
              stack: error.stack
            });
            return false;
          }
        }

        // Try all versions with sandbox
        for (let version of versions) {
          if (await tryInit(version)) {
            if (!hasResolved) {
              hasResolved = true;
              const postInitReady = (typeof window.Pi.isReady === 'boolean' && window.Pi.isReady) || 
                                    (typeof window.Pi.initialized === 'boolean' && window.Pi.initialized);
              console.log('Checkpoint: Post-init Pi SDK ready state:', postInitReady);
              return postInitReady;
            }
          }
        }

        // If sandbox failed, try without sandbox
        if (useSandbox) {
          console.log('Checkpoint: Sandbox init failed, trying without sandbox...');
          useSandbox = false;
          for (let version of versions) {
            if (await tryInit(version)) {
              if (!hasResolved) {
                hasResolved = true;
                const postInitReady = (typeof window.Pi.isReady === 'boolean' && window.Pi.isReady) || 
                                      (typeof window.Pi.initialized === 'boolean' && window.Pi.initialized);
                console.log('Checkpoint: Post-init Pi SDK ready state (no sandbox):', postInitReady);
                return postInitReady;
              }
            }
          }
        }

        // Force SDK reload if all init attempts fail
        console.log('Checkpoint: All init attempts failed, forcing SDK reload...');
        sdkLoadAttempts++;
        if (sdkLoadAttempts < maxAttempts) {
          console.log(`Checkpoint: Reloading SDK with URL ${sdkUrls[sdkLoadAttempts]}`);
          try {
            await loadSdk(sdkUrls[sdkLoadAttempts]);
            // Reset useSandbox for new attempt
            useSandbox = true;
            try {
              const response = await fetch('https://api.testnet.minepi.com/v2/health', {
                method: 'GET',
                headers: {
                  'Authorization': 'Key xxphzwyfmzalumwmiewge3hshjos3dsqwemu1hyuerpiomyff97grrsgxfvhpzdq'
                },
                signal: AbortSignal.timeout(5000)
              });
              if (!response.ok) {
                console.warn('Checkpoint: Testnet health check failed after reload:', response.status, response.statusText);
                useSandbox = false;
              }
            } catch (error) {
              console.warn('Checkpoint: Testnet health check error after reload:', {
                message: error.message || 'Unknown error',
                stack: error.stack
              });
              useSandbox = false;
            }
            for (let version of versions) {
              if (await tryInit(version)) {
                if (!hasResolved) {
                  hasResolved = true;
                  const postInitReady = (typeof window.Pi.isReady === 'boolean' && window.Pi.isReady) || 
                                        (typeof window.Pi.initialized === 'boolean' && window.Pi.initialized);
                  console.log('Checkpoint: Post-reload init Pi SDK ready state:', postInitReady);
                  return postInitReady;
                }
              }
            }
          } catch (err) {
            console.error(`Checkpoint: SDK reload attempt ${sdkLoadAttempts}/${maxAttempts} failed:`, {
              message: err.message || 'Unknown error',
              stack: err.stack
            });
          }
        }

        console.log('Checkpoint: Starting retry loop for Pi SDK initialization');
        return new Promise((resolve, reject) => {
          const retryInterval = setInterval(async () => {
            const currentReady = (typeof window.Pi.isReady === 'boolean' && window.Pi.isReady) || 
                                 (typeof window.Pi.initialized === 'boolean' && window.Pi.initialized);
            if (currentReady) {
              if (!hasResolved) {
                hasResolved = true;
                clearInterval(retryInterval);
                clearTimeout(timeoutTimer);
                console.log(`Checkpoint: Pi SDK is ready after ${retries} retries (isReady: ${window.Pi.isReady}, initialized: ${window.Pi.initialized})`);
                resolve(true);
              }
              return;
            }

            if (retries >= maxRetries) {
              clearInterval(retryInterval);
              clearTimeout(timeoutTimer);
              if (!hasResolved) {
                hasResolved = true;
                console.error(`Checkpoint: Pi SDK failed to initialize after ${maxRetries} retries`);
                reject(new Error('Pi SDK failed to initialize after retries'));
              }
              return;
            }

            console.log(`Checkpoint: Pi SDK not ready, retrying (${retries + 1}/${maxRetries})...`);
            for (let version of versions) {
              if (await tryInit(version)) {
                if (!hasResolved) {
                  hasResolved = true;
                  const postRetryReady = (typeof window.Pi.isReady === 'boolean' && window.Pi.isReady) || 
                                         (typeof window.Pi.initialized === 'boolean' && window.Pi.initialized);
                  console.log('Checkpoint: Post-retry Pi SDK ready state:', postRetryReady);
                  clearInterval(retryInterval);
                  clearTimeout(timeoutTimer);
                  resolve(postRetryReady);
                }
                return;
              }
            }
            retries++;
          }, delayMs);

          const timeoutTimer = setTimeout(() => {
            if (!hasResolved) {
              hasResolved = true;
              clearInterval(retryInterval);
              console.error(`Checkpoint: Pi SDK initialization timed out after ${timeoutMs}ms`);
              reject(new Error('Pi SDK initialization timed out'));
            }
          }, timeoutMs);
        });
      } catch (error) {
        console.error('Checkpoint: ensurePiSDKReady error:', {
          message: error.message || 'Unknown error',
          stack: error.stack
        });
        throw error;
      }
    }

    async function debugPiSDK() {
      console.log('Checkpoint: Debugging Pi SDK...');
      const debugInfo = {
        timestamp: new Date().toISOString(),
        isPiBrowser: isPiBrowser(),
        windowPiExists: !!window.Pi,
        piIsReady: typeof window.Pi?.isReady === 'boolean' ? window.Pi.isReady : 'undefined',
        piInitialized: typeof window.Pi?.initialized === 'boolean' ? window.Pi.initialized : 'undefined',
        piSdkProperties: window.Pi ? Object.keys(window.Pi) : [],
        piSdkDetails: window.Pi ? {
          initExists: typeof window.Pi.init === 'function',
          authenticateExists: typeof window.Pi.authenticate === 'function',
          createPaymentExists: typeof window.Pi.createPayment === 'function'
        } : {},
        appId: 'marketmate',
        sandbox: true,
        userAgent: navigator.userAgent,
        sdkUrls: sdkUrls,
        sdkLoadError: 'None',
        sdkInitError: 'None'
      };
      console.log('Initial Pi SDK Debug Info:', debugInfo);

      try {
        console.log('Checkpoint: Attempting to ping Testnet server...');
        const response = await fetch('https://api.testnet.minepi.com/v2/health', {
          method: 'GET',
          headers: {
            'Authorization': 'Key xxphzwyfmzalumwmiewge3hshjos3dsqwemu1hyuerpiomyff97grrsgxfvhpzdq'
          },
          signal: AbortSignal.timeout(5000)
        });
        debugInfo.testnetHealth = {
          status: response.status,
          ok: response.ok,
          statusText: response.statusText
        };
        try {
          debugInfo.testnetHealth.body = await response.text();
        } catch (e) {
          debugInfo.testnetHealth.body = 'Failed to read body';
        }
      } catch (error) {
        debugInfo.testnetHealth = {
          error: error.message || 'Unknown error',
          code: error.code,
          stack: error.stack
        };
      }

      console.log('Updated Pi SDK Debug Info (post-Testnet):', debugInfo);

      if (!debugInfo.windowPiExists) {
        console.log('Checkpoint: Attempting to load Pi SDK...');
        try {
          await loadSdk(sdkUrls[0]);
          debugInfo.windowPiExists = !!window.Pi;
          debugInfo.piIsReady = typeof window.Pi?.isReady === 'boolean' ? window.Pi.isReady : 'undefined';
          debugInfo.piInitialized = typeof window.Pi?.initialized === 'boolean' ? window.Pi.initialized : 'undefined';
          debugInfo.piSdkProperties = window.Pi ? Object.keys(window.Pi) : [];
          debugInfo.piSdkDetails = window.Pi ? {
            initExists: typeof window.Pi.init === 'function',
            authenticateExists: typeof window.Pi.authenticate === 'function',
            createPaymentExists: typeof window.Pi.createPayment === 'function'
          } : {};
          console.log('Post-load Pi SDK Debug Info:', debugInfo);
        } catch (error) {
          console.error('Checkpoint: Debug SDK load failed:', {
            message: error.message || 'Unknown error',
            stack: error.stack
          });
          debugInfo.sdkLoadError = error.message || 'Unknown error';
        }
      }

      if (debugInfo.windowPiExists && (debugInfo.piIsReady === 'undefined' || debugInfo.piInitialized === 'undefined' || !window.Pi.isReady && !window.Pi.initialized)) {
        console.warn('Checkpoint: Pi SDK loaded but not ready/initialized, inspecting SDK...');
        console.log('Checkpoint: Pi SDK details:', debugInfo.piSdkDetails);
      }

      if (debugInfo.windowPiExists && (debugInfo.piIsReady !== true && debugInfo.piInitialized !== true)) {
        console.log('Checkpoint: Attempting to initialize Pi SDK...');
        try {
          const isReady = await ensurePiSDKReady();
          debugInfo.piIsReady = typeof window.Pi?.isReady === 'boolean' ? window.Pi.isReady : 'undefined';
          debugInfo.piInitialized = typeof window.Pi?.initialized === 'boolean' ? window.Pi.initialized : 'undefined';
          debugInfo.piSdkProperties = window.Pi ? Object.keys(window.Pi) : [];
          debugInfo.piSdkDetails = window.Pi ? {
            initExists: typeof window.Pi.init === 'function',
            authenticateExists: typeof window.Pi.authenticate === 'function',
            createPaymentExists: typeof window.Pi.createPayment === 'function'
          } : {};
          console.log('Post-init Pi SDK Debug Info:', debugInfo);
        } catch (error) {
          console.error('Checkpoint: Debug SDK init failed:', {
            message: error.message || 'Unknown error',
            stack: error.stack
          });
          debugInfo.sdkInitError = error.message || 'Unknown error';
        }
      }

      console.log('Final Pi SDK Debug Info:', debugInfo);
      displayDebugInfo(debugInfo);
    }

    function displayDebugInfo(debugInfo) {
      const debugPanel = document.getElementById('debug-panel');
      const debugContent = document.getElementById('debug-content');
      if (debugPanel && debugContent) {
        debugContent.textContent = `
Timestamp: ${debugInfo.timestamp}
Is Pi Browser: ${debugInfo.isPiBrowser}
Pi SDK Loaded: ${debugInfo.windowPiExists}
Pi SDK Ready: ${debugInfo.piIsReady}
Pi SDK Initialized: ${debugInfo.piInitialized}
Pi SDK Properties: ${JSON.stringify(debugInfo.piSdkProperties, null, 2)}
Pi SDK Details: ${JSON.stringify(debugInfo.piSdkDetails, null, 2)}
App ID: ${debugInfo.appId}
Sandbox Mode: ${debugInfo.sandbox}
User Agent: ${debugInfo.userAgent}
SDK URLs: ${JSON.stringify(debugInfo.sdkUrls, null, 2)}
Testnet Health: ${JSON.stringify(debugInfo.testnetHealth, null, 2)}
SDK Load Error: ${debugInfo.sdkLoadError}
SDK Init Error: ${debugInfo.sdkInitError}
        `.trim();
        debugPanel.classList.remove('hidden');
        debugPanel.scrollIntoView({ behavior: 'smooth' });
      } else {
        console.warn('Debug panel elements not found:', { debugPanel, debugContent });
        alert('Debug info: ' + JSON.stringify(debugInfo, null, 2));
      }
      console.log('Displayed debug info:', debugInfo);
    }

    async function fetchPiPrice(currency) {
      console.log(`Checkpoint: Fetching Pi price for currency: ${currency}`);
      try {
        const response = await fetch(
          `https://api.coingecko.com/api/v3/simple/price?ids=pi-network&vs_currencies=${currency.toLowerCase()}`
        );
        if (!response.ok) {
          throw new Error(`Failed to fetch Pi price: ${response.status}`);
        }
        const data = await response.json();
        if (!data['pi-network'][currency.toLowerCase()]) {
          throw new Error('Currency not supported by CoinGecko');
        }
        const piPrice = data['pi-network'][currency.toLowerCase()];
        lastPiPrices[currency] = piPrice;
        console.log(`Checkpoint: Pi price fetched: ${currency} ${piPrice}`);
        return piPrice;
      } catch (error) {
        console.error('Checkpoint: fetchPiPrice error:', {
          message: error.message || 'Unknown error',
          stack: error.stack
        });
        throw error;
      }
    }

    async function updatePiPrice() {
      const manualPriceInput = document.getElementById('manual-price');
      try {
        const piPrice = await fetchPiPrice(currentCurrency);
        document.getElementById('pi-price').textContent = `${currentCurrency} ${piPrice.toFixed(4)}`;
        manualPriceInput.value = piPrice.toFixed(4);
      } catch (error) {
        document.getElementById('pi-price').textContent = 'Unavailable';
        if (lastPiPrices[currentCurrency]) {
          manualPriceInput.value = lastPiPrices[currentCurrency].toFixed(4);
        }
        showError('Pi price unavailable. Enter a manual price below.');
      }
    }

    function getEffectivePiPrice() {
      const manualPrice = parseFloat(document.getElementById('manual-price').value);
      if (!isNaN(manualPrice) && manualPrice > 0) {
        console.log('Checkpoint: Using manual Pi price:', manualPrice);
        return manualPrice;
      }
      console.log('Checkpoint: Using last fetched Pi price:', lastPiPrices[currentCurrency]);
      return lastPiPrices[currentCurrency];
    }

    function calculateAmount(amount, piPrice) {
      console.log('Checkpoint: Calculating amount:', { amount, piPrice, mode: currentMode });
      if (isNaN(amount) || amount <= 0) {
        showError(`Please enter a valid ${currentMode === 'usd-to-pi' ? currentCurrency : 'Pi'} amount.`);
        return null;
      }
      if (isNaN(piPrice) || piPrice <= 0) {
        showError('Pi price is unavailable. Enter a manual price below.');
        return null;
      }
      if (currentMode === 'usd-to-pi') {
        return (amount / piPrice).toFixed(2);
      } else {
        return (amount * piPrice).toFixed(2);
      }
    }

    function saveCalculation(input, result, paid = false) {
      console.log('Checkpoint: Saving calculation:', { input, result, paid });
      const calculation = {
        mode: currentMode,
        currency: currentCurrency,
        input: parseFloat(input).toFixed(2),
        result: parseFloat(result).toFixed(2),
        timestamp: new Date().toLocaleString(),
        paid: paid
      };
      recentCalculations.unshift(calculation);
      recentCalculations = recentCalculations.slice(0, 5);
      localStorage.setItem('piMarketMateCalculations', JSON.stringify(recentCalculations));
      updateRecentCalculations();
    }

    function updateRecentCalculations() {
      const list = document.getElementById('recent-calculations');
      if (!list) {
        console.warn('Checkpoint: Element with ID "recent-calculations" not found in DOM.');
        return;
      }
      console.log('Checkpoint: Updating recent calculations:', recentCalculations);
      list.innerHTML = '';
      recentCalculations.forEach(calc => {
        const li = document.createElement('li');
        li.className = 'py-1';
        if (calc.mode === 'usd-to-pi') {
          li.textContent = `${calc.timestamp}: ${calc.input} ${calc.currency} = ${calc.result} Pi${calc.paid ? ' (Paid)' : ''}`;
        } else {
          li.textContent = `${calc.timestamp}: ${calc.input} Pi = ${calc.result} ${calc.currency}${calc.paid ? ' (Paid)' : ''}`;
        }
        list.appendChild(li);
      });
    }

    function showError(message) {
      const errorDiv = document.getElementById('error');
      const errorMessage = document.getElementById('error-message');
      const displayMessage = message || 'An unknown error occurred';
      if (errorDiv && errorMessage) {
        errorMessage.textContent = displayMessage;
        errorDiv.classList.remove('hidden');
        document.getElementById('result')?.classList.add('hidden');
        errorDiv.scrollIntoView({ behavior: 'smooth' });
      } else {
        console.warn('Checkpoint: Error display elements not found:', { errorDiv, errorMessage });
        alert('Error: ' + displayMessage);
      }
      console.error('Checkpoint: Error displayed:', displayMessage);
    }

    function clearError() {
      const errorDiv = document.getElementById('error');
      if (errorDiv) {
        errorDiv.classList.add('hidden');
      } else {
        console.warn('Checkpoint: Error div not found for clearError');
      }
    }

    function setMode(mode) {
      console.log('Checkpoint: Setting mode:', mode);
      currentMode = mode;
      const usdToPiBtn = document.getElementById('usd-to-pi-btn');
      const piToUsdBtn = document.getElementById('pi-to-usd-btn');
      const inputLabelText = document.getElementById('input-label-text');
      const amountCheck = document.getElementById('amount-check');
      if (usdToPiBtn && piToUsdBtn && inputLabelText && amountCheck) {
        if (mode === 'usd-to-pi') {
          usdToPiBtn.classList.remove('bg-gray-300', 'text-gray-700');
          usdToPiBtn.classList.add('bg-blue-600', 'text-white');
          piToUsdBtn.classList.remove('bg-blue-600', 'text-white');
          piToUsdBtn.classList.add('bg-gray-300', 'text-gray-700');
          inputLabelText.textContent = `2. ENTER AMOUNT (${currentCurrency}):`;
        } else {
          piToUsdBtn.classList.remove('bg-gray-300', 'text-gray-700');
          piToUsdBtn.classList.add('bg-blue-600', 'text-white');
          usdToPiBtn.classList.remove('bg-blue-600', 'text-white');
          usdToPiBtn.classList.add('bg-gray-300', 'text-gray-700');
          inputLabelText.textContent = '2. ENTER AMOUNT (PI):';
        }
        document.getElementById('amount').value = '';
        amountCheck.classList.add('hidden');
        document.getElementById('result')?.classList.add('hidden');
      } else {
        console.warn('Checkpoint: Mode toggle elements not found:', { usdToPiBtn, piToUsdBtn, inputLabelText, amountCheck });
      }
    }

    function isPiBrowser() {
      const hostname = window.location.hostname.toLowerCase();
      const userAgent = navigator.userAgent.toLowerCase();
      const isPi = hostname.includes('pinet.com') || hostname.includes('marketmate5838.pinet.com') || hostname.includes('pimarketmate.com') || userAgent.includes('pi browser');
      console.log('Checkpoint: Pi Browser check:', { isPi, hostname, userAgent });
      return isPi;
    }

    async function initiatePayment(amount, memo, metadata) {
      console.log('Checkpoint: Initiating payment:', { amount, memo, metadata, timestamp: new Date().toISOString() });
      try {
        if (!isPiBrowser()) {
          showError('Please open this app in Pi Browser to make a payment.');
          return;
        }

        console.log('Checkpoint: Validating payment data...');
        if (!amount || isNaN(amount) || amount <= 0) {
          throw new Error('Invalid payment amount');
        }
        if (!memo || typeof memo !== 'string') {
          throw new Error('Invalid payment memo');
        }
        if (!metadata || typeof metadata !== 'object') {
          throw new Error('Invalid payment metadata');
        }

        // Mock payment mode for testing
        const isMockMode = localStorage.getItem('piMarketMateMockPayment') === 'true';
        if (isMockMode) {
          console.log('Checkpoint: Running in mock payment mode');
          alert(`Mock Payment Successful! Amount: ${amount} Pi, Memo: ${memo}`);
          saveCalculation(amount, amount, true);
          return;
        }

        console.log('Checkpoint: Checking Pi SDK availability...');
        if (!window.Pi || typeof window.Pi.init !== 'function') {
          console.log('Checkpoint: window.Pi is undefined or malformed, attempting to reload SDK...');
          sdkLoadAttempts = 0;
          try {
            await loadSdk(sdkUrls[0]);
            if (!window.Pi || typeof window.Pi.init !== 'function') {
              throw new Error('Pi SDK is not available or malformed after retry. Please ensure you\'re in the Pi Browser.');
            }
          } catch (err) {
            console.error('Checkpoint: SDK reload failed:', {
              message: err.message || 'Unknown error',
              stack: err.stack
            });
            throw new Error('Pi SDK is not available: ' + (err.message || 'Unknown error'));
          }
        }

        console.log('Checkpoint: Pi SDK object properties:', Object.keys(window.Pi));
        console.log('Checkpoint: Ensuring Pi SDK is ready...');
        try {
          const isReady = await ensurePiSDKReady();
          if (!isReady) {
            throw new Error('Pi SDK failed to become ready');
          }
        } catch (err) {
          console.error('Checkpoint: SDK ready error:', {
            message: err.message || 'Unknown error',
            stack: err.stack
          });
          throw new Error('Pi SDK initialization failed: ' + (err.message || 'Unknown error'));
        }

        console.log('Checkpoint: Pi SDK ready, proceeding with authentication...');
        console.log('Checkpoint: Authenticating user...');
        let authResult;
        const authAttempts = 2;
        for (let attempt = 1; attempt <= authAttempts; attempt++) {
          try {
            console.log(`Checkpoint: Authentication attempt ${attempt}/${authAttempts}`);
            authResult = await window.Pi.authenticate(['payments', 'username'], (payment) => {
              console.log('Checkpoint: Incomplete payment found:', payment);
            });
            console.log('Checkpoint: User authenticated:', authResult);
            break;
          } catch (authErr) {
            console.error(`Checkpoint: Authentication attempt ${attempt} failed:`, {
              message: authErr.message || 'Unknown authentication error',
              stack: authErr.stack
            });
            if (authErr.message && authErr.message.includes('e.every')) {
              console.log('Checkpoint: Retrying authentication without scopes...');
              try {
                authResult = await window.Pi.authenticate({}, (payment) => {
                  console.log('Checkpoint: Incomplete payment found (fallback):', payment);
                });
                console.log('Checkpoint: User authenticated (fallback):', authResult);
                break;
              } catch (fallbackErr) {
                console.error('Checkpoint: Fallback authentication failed:', {
                  message: fallbackErr.message || 'Unknown error',
                  stack: fallbackErr.stack
                });
                if (attempt === authAttempts) {
                  throw new Error('Authentication failed: ' + (fallbackErr.message || 'Unknown error'));
                }
              }
            } else {
              if (attempt === authAttempts) {
                throw new Error('Authentication failed: ' + (authErr.message || 'Unknown error'));
              }
            }
          }
        }

        console.log(`Checkpoint: Initiating payment for ${amount} Pi...`);
        const paymentData = {
          amount: amount,
          memo: memo,
          metadata: metadata
        };
        const paymentCallbacks = {
          onReadyForServerApproval: async (paymentId) => {
            console.log('Checkpoint: Payment ID ready for approval:', paymentId);
            try {
              const response = await fetch('/api/payments/approve', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ paymentId })
              });
              const responseDetails = {
                status: response.status,
                ok: response.ok,
                statusText: response.statusText,
                headers: Object.fromEntries(response.headers.entries())
              };
              let responseBody = 'No body';
              try {
                responseBody = await response.text();
              } catch (e) {
                console.warn('Checkpoint: Failed to read approval response body:', e);
              }
              console.log('Checkpoint: Approval response:', { ...responseDetails, body: responseBody });
              if (!response.ok) {
                throw new Error(`Server approval failed: ${response.status} ${response.statusText}`);
              }
              console.log('Checkpoint: Payment approved by server');
            } catch (error) {
              console.error('Checkpoint: Server approval error:', {
                message: error.message || 'Unknown error',
                stack: error.stack
              });
              throw new Error('Payment approval failed: ' + (error.message || 'Unknown error'));
            }
          },
          onReadyForServerCompletion: async (paymentId, txid) => {
            console.log('Checkpoint: Payment ready for completion:', paymentId, 'txid:', txid);
            try {
              const response = await fetch('/api/payments/complete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ paymentId, txid })
              });
              const responseDetails = {
                status: response.status,
                ok: response.ok,
                statusText: response.statusText,
                headers: Object.fromEntries(response.headers.entries())
              };
              let responseBody = 'No body';
              try {
                responseBody = await response.text();
              } catch (e) {
                console.warn('Checkpoint: Failed to read completion response body:', e);
              }
              console.log('Checkpoint: Completion response:', { ...responseDetails, body: responseBody });
              if (!response.ok) {
                throw new Error(`Server completion failed: ${response.status} ${response.statusText}`);
              }
              console.log('Checkpoint: Payment completed successfully');
              saveCalculation(amount, amount, true);
              alert('Payment successful! Transaction ID: ' + txid);
            } catch (error) {
              console.error('Checkpoint: Server completion error:', {
                message: error.message || 'Unknown error',
                stack: error.stack
              });
              throw new Error('Payment completion failed: ' + (error.message || 'Unknown error'));
            }
          },
          onCancel: () => {
            console.log('Checkpoint: Payment cancelled by user');
            showError('Payment cancelled by user.');
          },
          onError: (error) => {
            console.error('Checkpoint: Payment error:', {
              message: error.message || 'Unknown payment error',
              stack: error.stack
            });
            showError('Payment failed: ' + (error.message || 'Unknown error'));
          }
        };

        console.log('Checkpoint: Creating payment with data:', paymentData);
        try {
          const paymentPromise = window.Pi.createPayment(paymentData, paymentCallbacks);
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Payment creation timed out after 30s')), 30000);
          });
          const payment = await Promise.race([paymentPromise, timeoutPromise]);
          console.log('Checkpoint: Payment created:', payment);
        } catch (paymentErr) {
          console.error('Checkpoint: Payment creation error:', {
            message: paymentErr.message || 'Unknown error',
            stack: paymentErr.stack
          });
          throw new Error('Payment creation failed: ' + (paymentErr.message || 'Unknown error'));
        }
      } catch (error) {
        console.error('Checkpoint: Error in initiatePayment:', {
          message: error.message || 'Unknown error',
          stack: error.stack
        });
        showError('An error occurred during payment: ' + (error.message || 'Unknown error'));
      }
    }

    // Event Listeners
    function setupEventListeners() {
      console.log('Checkpoint: Setting up event listeners');
      const usdToPiBtn = document.getElementById('usd-to-pi-btn');
      if (usdToPiBtn) {
        usdToPiBtn.addEventListener('click', () => setMode('usd-to-pi'));
        usdToPiBtn.addEventListener('touchstart', () => setMode('usd-to-pi'));
      } else {
        console.warn('Checkpoint: Element "usd-to-pi-btn" not found');
      }

      const piToUsdBtn = document.getElementById('pi-to-usd-btn');
      if (piToUsdBtn) {
        piToUsdBtn.addEventListener('click', () => setMode('pi-to-usd'));
        piToUsdBtn.addEventListener('touchstart', () => setMode('pi-to-usd'));
      } else {
        console.warn('Checkpoint: Element "pi-to-usd-btn" not found');
      }

      const currencySelect = document.getElementById('currency');
      const currencyCheck = document.getElementById('currency-check');
      if (currencySelect && currencyCheck) {
        currencySelect.value = currentCurrency;
        currencyCheck.classList.remove('hidden');
        currencySelect.addEventListener('change', (e) => {
          console.log('Checkpoint: Currency changed:', e.target.value);
          const selectedCurrency = e.target.value.toUpperCase();
          if (lastPiPrices.hasOwnProperty(selectedCurrency)) {
            currentCurrency = selectedCurrency;
            localStorage.setItem('piMarketMateCurrency', selectedCurrency);
            document.getElementById('input-label-text').textContent = 
              currentMode === 'usd-to-pi' ? 
              `2. ENTER AMOUNT (${currentCurrency}):` : 
              '2. ENTER AMOUNT (PI):';
            currencyCheck.classList.remove('hidden');
            updatePiPrice();
          } else {
            currencyCheck.classList.add('hidden');
          }
        });
      } else {
        console.warn('Checkpoint: Currency elements not found:', { currencySelect, currencyCheck });
      }

      const amountInput = document.getElementById('amount');
      const amountCheck = document.getElementById('amount-check');
      if (amountInput && amountCheck) {
        amountInput.addEventListener('input', (e) => {
          const amount = parseFloat(e.target.value);
          console.log('Checkpoint: Amount input:', amount);
          if (!isNaN(amount) && amount > 0) {
            amountCheck.classList.remove('hidden');
          } else {
            amountCheck.classList.add('hidden');
          }
        });
      } else {
        console.warn('Checkpoint: Amount elements not found:', { amountInput, amountCheck });
      }

      const calculateBtn = document.getElementById('calculate-btn');
      if (calculateBtn) {
        calculateBtn.addEventListener('click', async () => {
          console.log('Checkpoint: Calculate button clicked');
          clearError();
          const amount = parseFloat(document.getElementById('amount').value);
          try {
            let piPrice = getEffectivePiPrice();
            if (!piPrice) {
              await fetchPiPrice(currentCurrency);
              piPrice = getEffectivePiPrice();
            }
            const result = calculateAmount(amount, piPrice);
            if (result) {
              const prefix = currentMode === 'usd-to-pi' ? 'You need: ' : 'You get: ';
              const value = currentMode === 'usd-to-pi' ? `${result} Pi` : `${result} ${currentCurrency}`;
              const resultTextPrefix = document.getElementById('result-text-prefix');
              const resultValue = document.getElementById('result-value');
              const resultDiv = document.getElementById('result');
              if (resultTextPrefix && resultValue && resultDiv) {
                resultTextPrefix.textContent = prefix;
                resultValue.textContent = value;
                resultDiv.classList.remove('hidden');
                if (currentMode === 'usd-to-pi') {
                  lastCalculatedPiAmount = parseFloat(result);
                }
                console.log('Checkpoint: Calculation result:', { prefix, value, lastCalculatedPiAmount });
              } else {
                console.warn('Checkpoint: Result elements not found:', { resultTextPrefix, resultValue, resultDiv });
              }
              saveCalculation(amount, result);
            }
          } catch (error) {
            console.error('Checkpoint: Calculate error:', {
              message: error.message || 'Unknown error',
              stack: error.stack
            });
            showError('Pi price unavailable. Enter a manual price below.');
          }
        });
        calculateBtn.addEventListener('touchstart', async () => {
          console.log('Checkpoint: Calculate button touched');
          clearError();
          const amount = parseFloat(document.getElementById('amount').value);
          try {
            let piPrice = getEffectivePiPrice();
            if (!piPrice) {
              await fetchPiPrice(currentCurrency);
              piPrice = getEffectivePiPrice();
            }
            const result = calculateAmount(amount, piPrice);
            if (result) {
              const prefix = currentMode === 'usd-to-pi' ? 'You need: ' : 'You get: ';
              const value = currentMode === 'usd-to-pi' ? `${result} Pi` : `${result} ${currentCurrency}`;
              const resultTextPrefix = document.getElementById('result-text-prefix');
              const resultValue = document.getElementById('result-value');
              const resultDiv = document.getElementById('result');
              if (resultTextPrefix && resultValue && resultDiv) {
                resultTextPrefix.textContent = prefix;
                resultValue.textContent = value;
                resultDiv.classList.remove('hidden');
                if (currentMode === 'usd-to-pi') {
                  lastCalculatedPiAmount = parseFloat(result);
                }
                console.log('Checkpoint: Calculation result:', { prefix, value, lastCalculatedPiAmount });
              } else {
                console.warn('Checkpoint: Result elements not found:', { resultTextPrefix, resultValue, resultDiv });
              }
              saveCalculation(amount, result);
            }
          } catch (error) {
            console.error('Checkpoint: Calculate error:', {
              message: error.message || 'Unknown error',
              stack: error.stack
            });
            showError('Pi price unavailable. Enter a manual price below.');
          }
        });
      } else {
        console.warn('Checkpoint: Element "calculate-btn" not found');
      }

      const payWithPiBtn = document.getElementById('pay-with-pi-btn');
      if (payWithPiBtn) {
        payWithPiBtn.addEventListener('click', () => {
          console.log('Checkpoint: Pay with Pi button clicked');
          if (!isPiBrowser()) {
            showError('Please open this app in Pi Browser to make a payment.');
            return;
          }
          if (currentMode !== 'usd-to-pi' || !lastCalculatedPiAmount) {
            showError('Please calculate a Pi amount first using "Currency to Pi" mode.');
            return;
          }
          initiatePayment(lastCalculatedPiAmount, 'Payment for calculated amount via Pi Market Mate', { app: 'Pi Market Mate', type: 'calculated_payment' });
        });
        payWithPiBtn.addEventListener('touchstart', () => {
          console.log('Checkpoint: Pay with Pi button touched');
          if (!isPiBrowser()) {
            showError('Please open this app in Pi Browser to make a payment.');
            return;
          }
          if (currentMode !== 'usd-to-pi' || !lastCalculatedPiAmount) {
            showError('Please calculate a Pi amount first using "Currency to Pi" mode.');
            return;
          }
          initiatePayment(lastCalculatedPiAmount, 'Payment for calculated amount via Pi Market Mate', { app: 'Pi Market Mate', type: 'calculated_payment' });
        });
      } else {
        console.warn('Checkpoint: Element "pay-with-pi-btn" not found');
      }

      const debugBtn = document.getElementById('debug-btn');
      if (debugBtn) {
        debugBtn.addEventListener('click', debugPiSDK);
        debugBtn.addEventListener('touchstart', debugPiSDK);
      } else {
        console.warn('Checkpoint: Element "debug-btn" not found');
      }

      const closeDebugBtn = document.getElementById('close-debug');
      if (closeDebugBtn) {
        closeDebugBtn.addEventListener('click', () => {
          console.log('Checkpoint: Close debug panel clicked');
          const debugPanel = document.getElementById('debug-panel');
          if (debugPanel) {
            debugPanel.classList.add('hidden');
          }
        });
        closeDebugBtn.addEventListener('touchstart', () => {
          console.log('Checkpoint: Close debug panel touched');
          const debugPanel = document.getElementById('debug-panel');
          if (debugPanel) {
            debugPanel.classList.add('hidden');
          }
        });
      } else {
        console.warn('Checkpoint: Element "close-debug" not found');
      }

      const donationLink = document.getElementById('donation-link');
      const donationPopup = document.getElementById('donation-popup');
      const overlay = document.getElementById('overlay');
      const confirmDonationBtn = document.getElementById('confirm-donation');
      const cancelDonationBtn = document.getElementById('cancel-donation');
      const donationAmountSelect = document.getElementById('donation-amount-select');

      if (donationLink) {
        donationLink.addEventListener('click', (e) => {
          e.preventDefault();
          console.log('Checkpoint: Donation link clicked');
          if (!isPiBrowser()) {
            showError('Please open this app in Pi Browser to make a donation.');
            return;
          }
          donationPopup.classList.add('active');
          overlay.classList.add('active');
        });
        donationLink.addEventListener('touchstart', (e) => {
          e.preventDefault();
          console.log('Checkpoint: Donation link touched');
          if (!isPiBrowser()) {
            showError('Please open this app in Pi Browser to make a donation.');
            return;
          }
          donationPopup.classList.add('active');
          overlay.classList.add('active');
        });
      } else {
        console.warn('Checkpoint: Element "donation-link" not found');
      }

      if (confirmDonationBtn) {
        confirmDonationBtn.addEventListener('click', async () => {
          console.log('Checkpoint: Confirm donation clicked');
          const selectedAmount = parseFloat(donationAmountSelect.value);
          if (isNaN(selectedAmount) || selectedAmount <= 0) {
            showError('Please select a valid donation amount.');
            return;
          }
          donationPopup.classList.remove('active');
          overlay.classList.remove('active');
          initiatePayment(selectedAmount, 'Donation to Pi Market Mate', { app: 'Pi Market Mate', subdomain: 'marketmate5838', walletAddress: 'GA4QWW7FATZUF4QYGMKK3NXMTDVDXWVD6U36UZJJWUHKO7GQ6AU5MMGP' });
        });
        confirmDonationBtn.addEventListener('touchstart', async () => {
          console.log('Checkpoint: Confirm donation touched');
          const selectedAmount = parseFloat(donationAmountSelect.value);
          if (isNaN(selectedAmount) || selectedAmount <= 0) {
            showError('Please select a valid donation amount.');
            return;
          }
          donationPopup.classList.remove('active');
          overlay.classList.remove('active');
          initiatePayment(selectedAmount, 'Donation to Pi Market Mate', { app: 'Pi Market Mate', subdomain: 'marketmate5838', walletAddress: 'GA4QWW7FATZUF4QYGMKK3NXMTDVDXWVD6U36UZJJWUHKO7GQ6AU5MMGP' });
        });
      } else {
        console.warn('Checkpoint: Element "confirm-donation" not found');
      }

      if (cancelDonationBtn) {
        cancelDonationBtn.addEventListener('click', () => {
          console.log('Checkpoint: Cancel donation clicked');
          donationPopup.classList.remove('active');
          overlay.classList.remove('active');
        });
        cancelDonationBtn.addEventListener('touchstart', () => {
          console.log('Checkpoint: Cancel donation touched');
          donationPopup.classList.remove('active');
          overlay.classList.remove('active');
        });
      } else {
        console.warn('Checkpoint: Element "cancel-donation" not found');
      }

      const privacyPolicyLink = document.getElementById('privacy-policy-link');
      const termsOfServiceLink = document.getElementById('terms-of-service-link');
      const textViewer = document.getElementById('text-viewer');
      const textContent = document.getElementById('text-content');
      const textFallback = document.getElementById('text-fallback');
      const textDownloadLink = document.getElementById('text-download-link');
      const closeTextBtn = document.getElementById('close-text');

      async function displayText(url, title) {
        console.log(`Checkpoint: Displaying text: ${title} from ${url}`);
        try {
          const response = await fetch(url);
          if (!response.ok) {
            throw new Error(`Failed to fetch ${title} (${response.status} ${response.statusText})`);
          }
          const contentType = response.headers.get('content-type');
          if (!contentType || !contentType.includes('text/plain')) {
            throw new Error(`Unexpected content type for ${title}: ${contentType || 'none'}`);
          }
          const text = await response.text();
          if (!text || text.trim() === '') {
            throw new Error(`${title} file is empty`);
          }
          textContent.textContent = text;
          textViewer.style.display = 'block';
          textFallback.classList.add('hidden');
          textDownloadLink.href = url;
        } catch (error) {
          console.error('Checkpoint: Display text error:', {
            message: error.message || 'Unknown error',
            stack: error.stack
          });
          let fallbackMessage = 'Failed to load the content. ';
          if (error.message.includes('Failed to fetch')) {
            fallbackMessage += `${title} may be missing or inaccessible. `;
          } else if (error.message.includes('Unexpected content type')) {
            fallbackMessage += `The server returned an invalid content type. `;
          } else if (error.message.includes('file is empty')) {
            fallbackMessage += `The ${title} file is empty. `;
          }
          fallbackMessage += `Please try again later or <a id="text-download-link" href="${url}" class="text-blue-600 hover:underline">download the file</a>.`;
          textContent.textContent = '';
          textFallback.innerHTML = fallbackMessage;
          textFallback.classList.remove('hidden');
        }
        textViewer.scrollIntoView({ behavior: 'smooth' });
      }

      if (privacyPolicyLink) {
        privacyPolicyLink.addEventListener('click', (e) => {
          e.preventDefault();
          console.log('Checkpoint: Privacy policy link clicked');
          const privacyPolicyUrl = 'https://raw.githubusercontent.com/doubleconnect1/PiMarketMate/main/docs/PrivacyPolicy.txt';
          displayText(privacyPolicyUrl, 'Privacy Policy');
        });
        privacyPolicyLink.addEventListener('touchstart', (e) => {
          e.preventDefault();
          console.log('Checkpoint: Privacy policy link touched');
          const privacyPolicyUrl = 'https://raw.githubusercontent.com/doubleconnect1/PiMarketMate/main/docs/PrivacyPolicy.txt';
          displayText(privacyPolicyUrl, 'Privacy Policy');
        });
      } else {
        console.warn('Checkpoint: Element "privacy-policy-link" not found');
      }

      if (termsOfServiceLink) {
        termsOfServiceLink.addEventListener('click', (e) => {
          e.preventDefault();
          console.log('Checkpoint: Terms of service link clicked');
          const termsOfServiceUrl = 'https://raw.githubusercontent.com/doubleconnect1/PiMarketMate/main/docs/TermsOfService.txt';
          displayText(termsOfServiceUrl, 'Terms of Service');
        });
        termsOfServiceLink.addEventListener('touchstart', (e) => {
          e.preventDefault();
          console.log('Checkpoint: Terms of service link touched');
          const termsOfServiceUrl = 'https://raw.githubusercontent.com/doubleconnect1/PiMarketMate/main/docs/TermsOfService.txt';
          displayText(termsOfServiceUrl, 'Terms of Service');
        });
      } else {
        console.warn('Checkpoint: Element "terms-of-service-link" not found');
      }

      if (closeTextBtn) {
        closeTextBtn.addEventListener('click', () => {
          console.log('Checkpoint: Close text viewer clicked');
          textViewer.style.display = 'none';
          textContent.textContent = '';
          textFallback.classList.add('hidden');
        });
        closeTextBtn.addEventListener('touchstart', () => {
          console.log('Checkpoint: Close text viewer touched');
          textViewer.style.display = 'none';
          textContent.textContent = '';
          textFallback.classList.add('hidden');
        });
      } else {
        console.warn('Checkpoint: Element "close-text" not found');
      }
    }

    // Initialize after DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      console.log('Checkpoint: DOM fully loaded, initializing app');
      setupEventListeners();
      setMode('usd-to-pi');
      updatePiPrice();
      updateRecentCalculations();
    });
  </script>
</body>
</html>