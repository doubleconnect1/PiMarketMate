<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pi Market Mate - Diagnostic</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      text-align: center;
    }
    button {
      padding: 10px;
      margin: 10px;
      font-size: 16px;
    }
    #error-message, #loading-message, #username {
      margin-top: 10px;
    }
    #error-message {
      color: red;
    }
    #loading-message {
      color: blue;
    }
    #username {
      color: green;
    }
  </style>
</head>
<body>
  <h1>Pi Market Mate</h1>
  <p>Pay 0.01 Pi to test:</p>
  <button onclick="createPayment()">Pay 0.01 Pi</button>
  <button onclick="testSdkInit()">Test SDK Init</button>
  <button onclick="checkStoredAuth()">Check Stored Auth</button>
  <button onclick="clearStoredAuth()">Clear Stored Auth</button>
  <button onclick="testNetwork()">Test Network</button>
  <br>
  <label><input type="checkbox" id="debugMode" checked> Enable Debug Mode</label>
  <div id="username"></div>
  <div id="loading-message"></div>
  <div id="error-message"></div>

  <script src="https://sdk.minepi.com/pi-sdk.js"></script>
  <script>
    // Configuration
    const appId = 'marketmate';
    const sdkVersion = '2.0';
    const sandbox = new URLSearchParams(window.location.search).get('useSandbox') !== 'false';

    // Utility to log messages
    function logMessage(message, isError = false) {
      if (document.getElementById('debugMode').checked) {
        console[isError ? 'error' : 'log'](`[${new Date().toISOString()}] ${message}`);
      }
    }

    // Ensure Pi SDK is ready
    async function ensurePiSDKReady() {
      logMessage('Checking if Pi SDK is ready...');
      const timeoutMs = 30000;
      const startTime = Date.now();
      while (!window.Pi && (Date.now() - startTime) < timeoutMs) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      if (!window.Pi) {
        logMessage(`Pi SDK initialization timed out after ${timeoutMs} ms`, true);
        return false;
      }
      logMessage(`Pi SDK version: ${window.Pi.version || 'unknown'}`);
      return true;
    }

    // Initialize Pi SDK
    async function initPiSDK() {
      logMessage(`Initializing Pi SDK with appId: ${appId}, version: ${sdkVersion}, sandbox: ${sandbox}`);
      try {
        await window.Pi.init({ version: sdkVersion, sandbox: sandbox, appId: appId });
        logMessage('Pi.init succeeded');
        return true;
      } catch (err) {
        logMessage(`Pi.init failed: ${err.message}, Stack: ${err.stack}`, true);
        throw err;
      }
    }

    // Test SDK initialization
    async function testSdkInit() {
      const errorMessage = document.getElementById('error-message');
      const loadingMessage = document.getElementById('loading-message');
      errorMessage.textContent = '';
      loadingMessage.textContent = 'Testing SDK initialization...';
      logMessage('Starting testSdkInit');

      try {
        if (!window.Pi) {
          logMessage('Pi SDK not loaded', true);
          throw new Error('Pi SDK not loaded');
        }

        const isReady = await ensurePiSDKReady();
        if (!isReady) {
          throw new Error('Pi SDK failed to initialize');
        }

        await initPiSDK();
        errorMessage.textContent = 'SDK initialization succeeded!';
      } catch (err) {
        logMessage(`SDK init failed: ${err.message}, Stack: ${err.stack}`, true);
        errorMessage.textContent = `SDK init failed: ${err.message}`;
      }
      loadingMessage.textContent = '';
    }

    // Store authentication result
    function storeAuthResult(authResult) {
      try {
        localStorage.setItem('piAuth', JSON.stringify(authResult));
        logMessage(`Stored auth result: ${JSON.stringify(authResult)}`);
      } catch (err) {
        logMessage(`Failed to store auth result: ${err.message}`, true);
      }
    }

    // Retrieve stored authentication
    function getStoredAuth() {
      try {
        const auth = localStorage.getItem('piAuth');
        if (auth) {
          logMessage(`Retrieved stored auth: ${auth}`);
          return JSON.parse(auth);
        }
        logMessage('No stored auth found');
        return null;
      } catch (err) {
        logMessage(`Failed to retrieve stored auth: ${err.message}`, true);
        return null;
      }
    }

    // Clear stored authentication
    function clearStoredAuth() {
      const errorMessage = document.getElementById('error-message');
      const loadingMessage = document.getElementById('loading-message');
      errorMessage.textContent = '';
      loadingMessage.textContent = 'Clearing stored authentication...';
      logMessage('Starting clearStoredAuth');

      try {
        localStorage.removeItem('piAuth');
        logMessage('Stored authentication cleared');
        errorMessage.textContent = 'Stored authentication cleared.';
      } catch (err) {
        logMessage(`Failed to clear stored auth: ${err.message}`, true);
        errorMessage.textContent = `Failed to clear stored auth: ${err.message}`;
      }
      loadingMessage.textContent = '';
    }

    // Check stored authentication
    function checkStoredAuth() {
      const errorMessage = document.getElementById('error-message');
      const loadingMessage = document.getElementById('loading-message');
      errorMessage.textContent = '';
      loadingMessage.textContent = 'Checking stored authentication...';
      logMessage('Starting checkStoredAuth');

      const auth = getStoredAuth();
      if (auth) {
        errorMessage.textContent = `Stored auth: UID=${auth.user?.uid}, Username=${auth.user?.username || 'N/A'}, Token=${auth.accessToken?.substring(0, 10)}...`;
      } else {
        errorMessage.textContent = 'No stored authentication found.';
      }
      loadingMessage.textContent = '';
    }

    // Test network connectivity
    async function testNetwork() {
      const errorMessage = document.getElementById('error-message');
      const loadingMessage = document.getElementById('loading-message');
      errorMessage.textContent = '';
      loadingMessage.textContent = 'Testing network connectivity...';
      logMessage('Starting testNetwork');

      try {
        logMessage(`Navigator online: ${navigator.onLine}`);
        const response = await fetch('https://api.minepi.com', { method: 'GET', mode: 'no-cors' });
        logMessage('Network test to https://api.minepi.com succeeded');
        errorMessage.textContent = 'Network connectivity to Pi API is OK.';
      } catch (err) {
        logMessage(`Network test failed: ${err.message}`, true);
        errorMessage.textContent = `Network test failed: ${err.message}`;
      }
      loadingMessage.textContent = '';
    }

    // Authenticate and create payment
    async function createPayment() {
      const errorMessage = document.getElementById('error-message');
      const loadingMessage = document.getElementById('loading-message');
      const usernameDisplay = document.getElementById('username');
      errorMessage.textContent = '';
      loadingMessage.textContent = 'Processing payment...';
      logMessage('Starting createPayment');

      try {
        if (!window.Pi) {
          logMessage('Pi SDK not loaded', true);
          throw new Error('Pi SDK not loaded');
        }

        const isReady = await ensurePiSDKReady();
        if (!isReady) {
          throw new Error('Pi SDK failed to initialize');
        }

        await initPiSDK();

        // Check stored authentication
        let authResult = getStoredAuth();
        if (!authResult || !authResult.accessToken) {
          logMessage('No valid stored authentication, authenticating user...');
          const scopes = ['payments', 'username'];
          try {
            authResult = await Promise.race([
              window.Pi.authenticate(scopes, (payment) => {
                logMessage(`Incomplete payment found: ${payment.identifier}`);
              }),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Authentication timed out after 10 seconds')), 10000))
            ]);
            logMessage(`Authentication succeeded: ${JSON.stringify(authResult)}`);
            storeAuthResult(authResult);
          } catch (err) {
            logMessage(`Authentication failed: ${err.message}, Stack: ${err.stack}`, true);
            throw err;
          }
        }

        // Display username
        if (authResult.user && authResult.user.username) {
          usernameDisplay.textContent = `Hello, ${authResult.user.username}!`;
          logMessage(`Displayed username: ${authResult.user.username}`);
        }

        // Create payment
        logMessage('Creating payment for 0.01 Pi...');
        const paymentData = {
          amount: 0.01,
          memo: 'Test payment for Pi Market Mate',
          metadata: { orderId: `order_${Date.now()}` }
        };
        const paymentCallbacks = {
          onReadyForServerApproval: async (paymentId) => {
            logMessage(`Payment ready for approval: ${paymentId}`);
            try {
              const response = await fetch('/api/payments/approve', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ paymentId })
              });
              const result = await response.json();
              if (!result.success) {
                throw new Error(`Approval failed: ${result.error || 'Unknown error'}`);
              }
              logMessage(`Payment approved: ${JSON.stringify(result)}`);
            } catch (err) {
              logMessage(`Approval error: ${err.message}`, true);
              throw err;
            }
          },
          onReadyForServerCompletion: async (paymentId, txid) => {
            logMessage(`Payment ready for completion: ${paymentId}, txid: ${txid}`);
            try {
              const response = await fetch('/api/payments/complete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ paymentId, txid })
              });
              const result = await response.json();
              if (!result.success) {
                throw new Error(`Completion failed: ${result.error || 'Unknown error'}`);
              }
              logMessage(`Payment completed: ${JSON.stringify(result)}`);
            } catch (err) {
              logMessage(`Completion error: ${err.message}`, true);
              throw err;
            }
          },
          onCancel: () => {
            logMessage('Payment cancelled');
            errorMessage.textContent = 'Payment was cancelled.';
            loadingMessage.textContent = '';
          },
          onError: (err) => {
            logMessage(`Payment error: ${err.message}`, true);
            errorMessage.textContent = `Payment failed: ${err.message}`;
            loadingMessage.textContent = '';
          }
        };

        await window.Pi.createPayment(paymentData, paymentCallbacks);
        logMessage('Payment initiated');
        errorMessage.textContent = 'Payment initiated! Check Pi wallet.';
      } catch (err) {
        logMessage(`Payment failed: ${err.message}, Stack: ${err.stack}`, true);
        errorMessage.textContent = `Payment failed: ${err.message}`;
      }
      loadingMessage.textContent = '';
    }
  </script>
</body>
</html>