<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pi Market Mate - Simple Payment</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      text-align: center;
    }
    input, button {
      padding: 10px;
      margin: 10px;
      font-size: 16px;
    }
    #error-message, #loading-message {
      margin-top: 10px;
    }
    #error-message {
      color: red;
    }
    #loading-message {
      color: blue;
    }
  </style>
</head>
<body>
  <h1>Pi Market Mate</h1>
  <p>Enter amount in Pi and pay:</p>
  <input type="number" id="amount" placeholder="Enter Pi amount" step="0.01" min="0">
  <br>
  <button onclick="initiatePayment()">Pay with Pi</button>
  <button onclick="testAuthentication()">Test Authentication</button>
  <button onclick="testMinimalAuth()">Test Minimal Auth</button>
  <button onclick="testUsernameAuth()">Test Username Auth</button>
  <button onclick="testNetwork()">Test Network</button>
  <button onclick="testAppId()">Test App ID</button>
  <button onclick="checkStoredAuth()">Check Stored Auth</button>
  <br>
  <label><input type="checkbox" id="debugMode" checked> Enable Debug Mode</label>
  <div id="loading-message"></div>
  <div id="error-message"></div>

  <script>
    const sdkUrls = [
      'https://sdk.minepi.com/pi-sdk.js',
      'https://cdn.jsdelivr.net/npm/@pi-network/pi-sdk@2.0.0/dist/pi-sdk.min.js'
    ];
    let sdkLoadAttempts = 0;

    // Utility to log messages
    function logMessage(message, isError = false) {
      if (document.getElementById('debugMode').checked) {
        console[isError ? 'error' : 'log'](`[${new Date().toISOString()}] ${message}`);
      }
    }

    // Load Pi SDK
    async function loadSdk(url) {
      logMessage(`Attempting to load SDK from: ${url}`);
      try {
        const script = document.createElement('script');
        script.src = url;
        script.async = true;
        const loadPromise = new Promise((resolve, reject) => {
          script.onload = () => {
            logMessage(`SDK loaded successfully from: ${url}`);
            logMessage(`Pi SDK version: ${window.Pi ? (window.Pi.version || 'unknown') : 'not loaded'}`);
            resolve(true);
          };
          script.onerror = () => {
            logMessage(`Failed to load SDK from: ${url}`, true);
            reject(new Error(`Failed to load SDK from ${url}`));
          };
        });
        document.head.appendChild(script);
        await loadPromise;
        return true;
      } catch (error) {
        logMessage(`SDK load error: ${error.message}`, true);
        return false;
      }
    }

    // Check if in Pi Browser
    function isPiBrowser() {
      const userAgent = navigator.userAgent.toLowerCase();
      const hostname = window.location.hostname.toLowerCase();
      const isPi = userAgent.includes('pi') || hostname.includes('minepi') || hostname.includes('pimarketmate');
      logMessage(`Pi Browser check: ${JSON.stringify({ isPi, userAgent, hostname })}`);
      return isPi;
    }

    // Ensure Pi SDK is ready
    async function ensurePiSDKReady() {
      logMessage('Checking if Pi SDK is ready...');
      const timeoutMs = 30000;
      const startTime = Date.now();
      while (!window.Pi && (Date.now() - startTime) < timeoutMs) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      if (!window.Pi) {
        logMessage(`Pi SDK initialization timed out after ${timeoutMs} ms`, true);
        return false;
      }
      logMessage(`Pi SDK is ready: ${JSON.stringify(window.Pi)}`);
      return true;
    }

    // Store authentication result
    function storeAuthResult(authResult) {
      try {
        localStorage.setItem('piAuth', JSON.stringify(authResult));
        logMessage(`Stored auth result: ${JSON.stringify(authResult)}`);
      } catch (err) {
        logMessage(`Failed to store auth result: ${err.message}`, true);
      }
    }

    // Retrieve stored authentication
    function getStoredAuth() {
      try {
        const auth = localStorage.getItem('piAuth');
        if (auth) {
          logMessage(`Retrieved stored auth: ${auth}`);
          return JSON.parse(auth);
        }
        logMessage('No stored auth found');
        return null;
      } catch (err) {
        logMessage(`Failed to retrieve stored auth: ${err.message}`, true);
        return null;
      }
    }

    // Check stored authentication
    function checkStoredAuth() {
      const errorMessage = document.getElementById('error-message');
      const loadingMessage = document.getElementById('loading-message');
      errorMessage.textContent = '';
      loadingMessage.textContent = 'Checking stored authentication...';
      logMessage('Starting checkStoredAuth');

      const auth = getStoredAuth();
      if (auth) {
        errorMessage.textContent = `Stored auth: UID=${auth.user?.uid}, Username=${auth.user?.username || 'N/A'}, Token=${auth.accessToken?.substring(0, 10)}...`;
      } else {
        errorMessage.textContent = 'No stored authentication found.';
      }
      loadingMessage.textContent = '';
    }

    // Test network connectivity
    async function testNetwork() {
      const errorMessage = document.getElementById('error-message');
      const loadingMessage = document.getElementById('loading-message');
      errorMessage.textContent = '';
      loadingMessage.textContent = 'Testing network connectivity...';
      logMessage('Starting testNetwork');

      try {
        logMessage(`Navigator online: ${navigator.onLine}`);
        const response = await fetch('https://api.minepi.com', { method: 'GET', mode: 'no-cors' });
        logMessage('Network test to https://api.minepi.com succeeded');
        errorMessage.textContent = 'Network connectivity to Pi API is OK.';
      } catch (err) {
        logMessage(`Network test failed: ${err.message}`, true);
        errorMessage.textContent = `Network test failed: ${err.message}`;
      }
      loadingMessage.textContent = '';
    }

    // Test App ID registration
    async function testAppId() {
      const errorMessage = document.getElementById('error-message');
      const loadingMessage = document.getElementById('loading-message');
      errorMessage.textContent = '';
      loadingMessage.textContent = 'Testing App ID registration...';
      logMessage('Starting testAppId');

      try {
        const sandbox = new URLSearchParams(window.location.search).get('useSandbox') !== 'false';
        const testUrl = sandbox
          ? 'https://sandbox.minepi.com/mobile-app-ui/app/marketmate'
          : 'https://api.minepi.com/mobile-app-ui/app/marketmate';
        logMessage(`Testing App ID at: ${testUrl}`);
        const response = await fetch(testUrl, { method: 'GET', mode: 'no-cors' });
        logMessage(`App ID test to ${testUrl} succeeded`);
        errorMessage.textContent = `App ID test succeeded (check logs for details).`;
      } catch (err) {
        logMessage(`App ID test failed: ${err.message}`, true);
        errorMessage.textContent = `App ID test failed: ${err.message}`;
      }
      loadingMessage.textContent = '';
    }

    // Test minimal authentication (no scopes)
    async function testMinimalAuth() {
      const errorMessage = document.getElementById('error-message');
      const loadingMessage = document.getElementById('loading-message');
      errorMessage.textContent = '';
      loadingMessage.textContent = 'Testing minimal authentication...';
      logMessage('Starting testMinimalAuth');

      try {
        if (!window.Pi) {
          logMessage('window.Pi is undefined, attempting to load SDK...');
          sdkLoadAttempts = 0;
          let sdkLoaded = false;
          for (const url of sdkUrls) {
            sdkLoadAttempts++;
            logMessage(`SDK load attempt ${sdkLoadAttempts} with URL: ${url}`);
            sdkLoaded = await loadSdk(url);
            if (sdkLoaded) break;
          }
          if (!sdkLoaded || !window.Pi) {
            throw new Error(`Pi SDK unavailable after ${sdkLoadAttempts} attempts`);
          }
        }

        const isReady = await ensurePiSDKReady();
        if (!isReady) {
          throw new Error('Pi SDK failed to initialize');
        }

        const sandbox = new URLSearchParams(window.location.search).get('useSandbox') !== 'false';
        logMessage(`Initializing Pi SDK with appId: marketmate, version: 2.0, sandbox: ${sandbox}`);
        try {
          await window.Pi.init({
            version: '2.0',
            sandbox: sandbox,
            appId: 'marketmate'
          });
          logMessage('Pi.init succeeded');
        } catch (err) {
          throw new Error(`Pi SDK initialization failed: ${err.message}`);
        }

        logMessage('Authenticating user with no scopes...');
        const authPromise = window.Pi.authenticate(
          [],
          () => {
            logMessage('Minimal authentication cancelled by user');
            errorMessage.textContent = 'Minimal authentication cancelled by user.';
            loadingMessage.textContent = '';
          }
        );
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Minimal authentication timed out after 10 seconds')), 10000);
        });
        const authResult = await Promise.race([authPromise, timeoutPromise]);
        logMessage(`Minimal authentication succeeded: ${JSON.stringify(authResult)}`);
        storeAuthResult(authResult);
        errorMessage.textContent = 'Minimal authentication succeeded!';
      } catch (err) {
        logMessage(`Minimal authentication failed: ${err.message}`, true);
        errorMessage.textContent = `Minimal authentication failed: ${err.message}`;
      }
      loadingMessage.textContent = '';
    }

    // Test username authentication
    async function testUsernameAuth() {
      const errorMessage = document.getElementById('error-message');
      const loadingMessage = document.getElementById('loading-message');
      errorMessage.textContent = '';
      loadingMessage.textContent = 'Testing username authentication...';
      logMessage('Starting testUsernameAuth');

      try {
        if (!window.Pi) {
          logMessage('window.Pi is undefined, attempting to load SDK...');
          sdkLoadAttempts = 0;
          let sdkLoaded = false;
          for (const url of sdkUrls) {
            sdkLoadAttempts++;
            logMessage(`SDK load attempt ${sdkLoadAttempts} with URL: ${url}`);
            sdkLoaded = await loadSdk(url);
            if (sdkLoaded) break;
          }
          if (!sdkLoaded || !window.Pi) {
            throw new Error(`Pi SDK unavailable after ${sdkLoadAttempts} attempts`);
          }
        }

        const isReady = await ensurePiSDKReady();
        if (!isReady) {
          throw new Error('Pi SDK failed to initialize');
        }

        const sandbox = new URLSearchParams(window.location.search).get('useSandbox') !== 'false';
        logMessage(`Initializing Pi SDK with appId: marketmate, version: 2.0, sandbox: ${sandbox}`);
        try {
          await window.Pi.init({
            version: '2.0',
            sandbox: sandbox,
            appId: 'marketmate'
          });
          logMessage('Pi.init succeeded');
        } catch (err) {
          throw new Error(`Pi SDK initialization failed: ${err.message}`);
        }

        logMessage('Authenticating user with username scope...');
        const authPromise = window.Pi.authenticate(
          ['username'],
          () => {
            logMessage('Username authentication cancelled by user');
            errorMessage.textContent = 'Username authentication cancelled by user.';
            loadingMessage.textContent = '';
          }
        );
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Username authentication timed out after 10 seconds')), 10000);
        });
        const authResult = await Promise.race([authPromise, timeoutPromise]);
        logMessage(`Username authentication succeeded: ${JSON.stringify(authResult)}`);
        storeAuthResult(authResult);
        errorMessage.textContent = 'Username authentication succeeded!';
      } catch (err) {
        logMessage(`Username authentication failed: ${err.message}`, true);
        errorMessage.textContent = `Username authentication failed: ${err.message}`;
      }
      loadingMessage.textContent = '';
    }

    // Test authentication (with payments scope)
    async function testAuthentication() {
      const errorMessage = document.getElementById('error-message');
      const loadingMessage = document.getElementById('loading-message');
      errorMessage.textContent = '';
      loadingMessage.textContent = 'Testing authentication...';
      logMessage('Starting testAuthentication');

      try {
        if (!window.Pi) {
          logMessage('window.Pi is undefined, attempting to load SDK...');
          sdkLoadAttempts = 0;
          let sdkLoaded = false;
          for (const url of sdkUrls) {
            sdkLoadAttempts++;
            logMessage(`SDK load attempt ${sdkLoadAttempts} with URL: ${url}`);
            sdkLoaded = await loadSdk(url);
            if (sdkLoaded) break;
          }
          if (!sdkLoaded || !window.Pi) {
            throw new Error(`Pi SDK unavailable after ${sdkLoadAttempts} attempts`);
          }
        }

        const isReady = await ensurePiSDKReady();
        if (!isReady) {
          throw new Error('Pi SDK failed to initialize');
        }

        const sandbox = new URLSearchParams(window.location.search).get('useSandbox') !== 'false';
        logMessage(`Initializing Pi SDK with appId: marketmate, version: 2.0, sandbox: ${sandbox}`);
        try {
          await window.Pi.init({
            version: '2.0',
            sandbox: sandbox,
            appId: 'marketmate'
          });
          logMessage('Pi.init succeeded');
        } catch (err) {
          throw new Error(`Pi SDK initialization failed: ${err.message}`);
        }

        logMessage('Authenticating user with payments scope...');
        const authPromise = window.Pi.authenticate(
          ['payments'],
          () => {
            logMessage('Authentication cancelled by user');
            errorMessage.textContent = 'Authentication cancelled by user.';
            loadingMessage.textContent = '';
          }
        );
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Authentication timed out after 10 seconds')), 10000);
        });
        const authResult = await Promise.race([authPromise, timeoutPromise]);
        logMessage(`User authenticated: ${JSON.stringify(authResult)}`);
        storeAuthResult(authResult);
        errorMessage.textContent = 'Authentication succeeded!';
      } catch (err) {
        logMessage(`Test authentication failed: ${err.message}`, true);
        errorMessage.textContent = `Test authentication failed: ${err.message}`;
      }
      loadingMessage.textContent = '';
    }

    // Initialize payment
    async function initiatePayment() {
      const amountInput = document.getElementById('amount');
      const amount = parseFloat(amountInput.value);
      const errorMessage = document.getElementById('error-message');
      const loadingMessage = document.getElementById('loading-message');
      const bypassAuth = new URLSearchParams(window.location.search).get('bypassAuth') === 'true';
      const sandbox = new URLSearchParams(window.location.search).get('useSandbox') !== 'false';

      errorMessage.textContent = '';
      loadingMessage.textContent = 'Processing payment...';
      logMessage(`Starting initiatePayment with amount: ${amount}, bypassAuth: ${bypassAuth}, sandbox: ${sandbox}`);

      try {
        if (!amount || amount <= 0) {
          errorMessage.textContent = 'Please enter a valid Pi amount.';
          logMessage(`Invalid amount: ${amount}`, true);
          loadingMessage.textContent = '';
          return;
        }

        if (!isPiBrowser()) {
          logMessage('isPiBrowser returned false, proceeding anyway for testing...');
        }

        logMessage('Checking window.Pi before loading SDK...');
        if (!window.Pi) {
          logMessage('window.Pi is undefined, attempting to load SDK...');
          sdkLoadAttempts = 0;
          let sdkLoaded = false;
          for (const url of sdkUrls) {
            sdkLoadAttempts++;
            logMessage(`SDK load attempt ${sdkLoadAttempts} with URL: ${url}`);
            try {
              sdkLoaded = await loadSdk(url);
              if (sdkLoaded) break;
            } catch (err) {
              logMessage(`SDK load attempt ${sdkLoadAttempts} failed: ${err.message}`, true);
            }
          }
          if (!sdkLoaded || !window.Pi) {
            errorMessage.textContent = 'Pi SDK is not available. Please ensure you\'re in the Pi Browser.';
            logMessage(`Pi SDK unavailable after ${sdkLoadAttempts} attempts`, true);
            loadingMessage.textContent = '';
            return;
          }
        }

        logMessage(`Pi SDK object: ${JSON.stringify(window.Pi)}`);
        const isReady = await ensurePiSDKReady();
        if (!isReady) {
          errorMessage.textContent = 'Pi SDK failed to initialize. Please try again.';
          logMessage('Pi SDK not ready', true);
          loadingMessage.textContent = '';
          return;
        }

        // Initialize Pi SDK
        logMessage(`Initializing Pi SDK with appId: marketmate, version: 2.0, sandbox: ${sandbox}`);
        try {
          await window.Pi.init({
            version: '2.0',
            sandbox: sandbox,
            appId: 'marketmate'
          });
          logMessage('Pi.init succeeded');
        } catch (err) {
          errorMessage.textContent = `Pi SDK initialization failed: ${err.message}`;
          logMessage(`Pi.init failed: ${err.message}`, true);
          loadingMessage.textContent = '';
          return;
        }

        // Check stored authentication
        let authResult = null;
        if (!bypassAuth) {
          authResult = getStoredAuth();
          if (authResult && authResult.accessToken) {
            logMessage('Using stored authentication');
          } else {
            logMessage('No valid stored authentication, authenticating user with payments scope...');
            try {
              const authPromise = window.Pi.authenticate(
                ['payments'],
                () => {
                  logMessage('Authentication cancelled by user');
                  errorMessage.textContent = 'Authentication cancelled by user.';
                  loadingMessage.textContent = '';
                }
              );
              const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Authentication timed out after 10 seconds')), 10000);
              });
              authResult = await Promise.race([authPromise, timeoutPromise]);
              logMessage(`User authenticated: ${JSON.stringify(authResult)}`);
              storeAuthResult(authResult);
            } catch (err) {
              errorMessage.textContent = `Authentication failed: ${err.message}`;
              logMessage(`Authentication failed: ${err.message}`, true);
              loadingMessage.textContent = '';
              return;
            }
          }
        } else {
          logMessage('Bypassing authentication for testing...');
        }

        // Create payment
        logMessage(`Creating payment for ${amount} Pi...`);
        try {
          const payment = await window.Pi.createPayment({
            amount: amount,
            memo: 'Payment for Pi Market Mate',
            metadata: { orderId: `order_${Date.now()}` }
          }, {
            onReadyForServerApproval: async (paymentId) => {
              logMessage(`Payment ready for approval: ${paymentId}`);
              try {
                const response = await fetch('/api/payments/approve', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ paymentId })
                });
                const result = await response.json();
                if (!result.success) {
                  throw new Error(`Approval failed: ${result.error || 'Unknown error'}`);
                }
                logMessage(`Payment approved: ${JSON.stringify(result)}`);
              } catch (err) {
                logMessage(`Approval error: ${err.message}`, true);
                throw err;
              }
            },
            onReadyForServerCompletion: async (paymentId, txid) => {
              logMessage(`Payment ready for completion: ${paymentId}, txid: ${txid}`);
              try {
                const response = await fetch('/api/payments/complete', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ paymentId, txid })
                });
                const result = await response.json();
                if (!result.success) {
                  throw new Error(`Completion failed: ${result.error || 'Unknown error'}`);
                }
                logMessage(`Payment completed: ${JSON.stringify(result)}`);
              } catch (err) {
                logMessage(`Completion error: ${err.message}`, true);
                throw err;
              }
            },
            onCancel: () => {
              logMessage('Payment cancelled');
              errorMessage.textContent = 'Payment was cancelled.';
              loadingMessage.textContent = '';
            },
            onError: (err) => {
              logMessage(`Payment error: ${err.message}`, true);
              errorMessage.textContent = `Payment failed: ${err.message}`;
              loadingMessage.textContent = '';
            }
          });
          logMessage(`Payment created: ${JSON.stringify(payment)}`);
          errorMessage.textContent = 'Payment initiated! Check Pi wallet.';
        } catch (err) {
          errorMessage.textContent = `Payment failed: ${err.message}`;
          logMessage(`Payment creation failed: ${err.message}`, true);
          loadingMessage.textContent = '';
          return;
        }
      } catch (err) {
        errorMessage.textContent = `An error occurred: ${err.message}`;
        logMessage(`Error in initiatePayment: ${err.message}`, true);
        loadingMessage.textContent = '';
      }
    }
  </script>
</body>
</html>